#!/bin/bash

# Print usage
usage() {
    cat << EOF

NAME
     runSSAKE.sh -- Run pipeline for paired assembly with SSAKE

SYNOPSIS
     runSSAKE.sh read1.fq read2.fq libraryFragmentLength basename

DESCRIPTION
     SSAKE is a genomics application for de novo assembly of millions
     of very short DNA sequences. It is an easy-to-use, robust,
     reliable and tractable assembly algorithm for short sequence
     reads, such as those generated by Illumina Ltd. See:
     https://github.com/ralatsdc/SSAKE/blob/master/readme.md. This
     script is a siple pipline using TQSFastq and SSAKE.

OPTIONS for TQSfastq
-f   File of filenames corresponding to fasta/fastq files with reads to
     interrogate
          ! Implicitly used in this script
-q   Phred quality score threshold (bases less than -q XX will be
     clipped, default -q 10, optional)
          ! Use -x for this script
-n   Number of consecutive -q 10 bases (default -n 30, optional)
     TODO: Check that -n should read -e below
-e   ASCII offset (33=standard 64=illumina, default -n 33, optional)
          ! Use -d for this script
-v   Runs in verbose mode (-v 1 = yes, default = no, optional)

OPTIONS for SSAKE
-f File containing all the [paired (-p 1)] reads (required)
          ! Implicitly used in this script
          With -p 1:
               ! Target insert size must be indicated at the end of
                 the header line (e.g. :400 for a 400bp
                 fragment/insert size)
               ! Paired reads must be separated by ":"
                    >header:400 (or >header_barcode:400)
                    ACGACACTATGCATAAGCAGACGAGCAGCGACGCAGCACG:GCGCACGACGCAGCACAGCAGCAGACGAC
               Scaffolding options considered with -p 1:
                    -e Error (%) allowed on mean distance e.g. -e 0.75
                       == distance +/- 75% (default -e 0.75, optional)
                    -l Minimum number of links (read pairs) to compute
                       scaffold (default -k 5, optional)
                    -a Maximum link ratio between two best contig
                       pairs *higher values lead to least accurate
                       scaffolding* (default -a 0.3, optional)
-g   Fasta file containing unpaired sequence reads (optional)
          ! Implicitly used in this script
-w   Minimum depth of coverage allowed for contigs (e.g. -w 1 = process
     all reads [v3.7 behavior], required, recommended -w 5)
          ! The assembly will stop when 50+ contigs with coverage < -w have been seen.
-s   Fasta file containing sequences to use as seeds exclusively
     (specify only if different from read set, optional)
          ! Ignored by this script
          TODO: Understand if these options are used only when -s is used
          -i Independent (de novo) assembly i.e Targets used to
             recruit reads for de novo assembly, not guide/seed
             reference-based assemblies (-i 1 = yes (default), 0 = no,
             optional)
          -j Target sequence word size to hash (default -j 15)
          -u Apply read space restriction to seeds while -s option in
             use (-u 1 = yes, default = no, optional)
-m   Minimum number of overlapping bases with the seed/contig during
     overhang consensus build up (default -m 20)
-o   Minimum number of reads needed to call a base during an extension
     (default -o 2)
-r   Minimum base ratio used to accept a overhang consensus base
     (default -r 0.7)
-t   Trim up to -t base(s) on the contig end when all possibilities have
     been exhausted for an extension (default -t 0, optional)
-c   Track base coverage and read position for each contig (default -c 0, optional)
-y   Ignore read mapping to consensus (-y 1 = yes, default = no, optional)
-h   Ignore read name/header *will use less RAM if set to -h 1* (-h 1 = yes, default = no,
     optional)
          ! Use -k for this script
-b   Base name for your output files (optional)
          ! Implicitly used in this script
-z   Minimum contig size to track base coverage and read position
     (default -z 100, optional)
-q   Break tie when no consensus base at position, pick random base
     (-q 1 = yes, default = no, optional)
-p   Paired-end reads used? (-p 1 = yes, default = no, optional)
          ! Implicitly used in this script
-v   Runs in verbose mode (-v 1 = yes, default = no, optional)

EOF
}

# Parse command line options
X_ARG=20
N_ARG=70
D_ARG=33
W_ARG=5
M_ARG=20
O_ARG=2
R_ARG=0.7
T_ARG=0
C_ARG=0
Y_ARG=0
K_ARG=0
Z_ARG=100
Q_ARG=0
V_ARG=0
while getopts "x:n:d:vw:m:o:r:tcykz:qph" opt; do
    case $opt in
        x)
	    X_ARG=$OPTARG
            ;;
        n)
            N_ARG=$OPTARG
            ;;
        d)
            D_ARG=$OPTARG
            ;;
        w)
            W_ARG=$OPTARG
            ;;
        m)
            M_ARG=$OPTARG
            ;;
        o)
            O_ARG=$OPTARG
            ;;
        r)
            R_ARG=$OPTARG
            ;;
        t)
            T_ARG=1
            ;;
        c)
            C_ARG=1
            ;;
        y)
            Y_ARG=1
            ;;
        k)
            K_ARG=1
            ;;
        z)
            Z_ARG=$OPTARG
            ;;
        q)
            Q_ARG=1
            ;;
        v)
            V_ARG=1
            ;;
        h)
	    usage
	    exit 0
	    ;;
	\?)
	    echo "Invalid option: -$OPTARG" >&2
	    usage
	    exit 1
	    ;;
	\:)
	    echo "Option -$OPTARG requires an argument." >&2
	    usage
	    exit 1
	    ;;
    esac
done

# Assign command line arguments
if [ "$1" == "" ] || [ "$2" == "" ] || [ "$3" == "" ] || [ "$4" == "" ]; then
    usage
    exit 1
else
    READ1FQ=$1
    READ2FQ=$2
    LFRAGLEN=$3
    BASENAME=$4
fi

# Run the pipeline
echo Running: runSSAKE.sh ${READ1FQ} ${READ2FQ} ${LFRAGLEN} ${BASENAME}
echo =================================================================================== 
echo ${DATE} : Running SSAKE assembly pipeline on reads file:
echo ${READ1FQ}
echo ${READ2FQ} 
echo target fragment length = ${LFRAGLEN} bp
echo basename for assembly : ${BASENAME}
DATE=`date`
echo -----------------------------------------------------------------------------------
echo ${DATE} : Trimming low quality bases, be patient...
echo -----------------------------------------------------------------------------------
echo ${READ1FQ} > filesToTrim.fof
echo ${READ2FQ} >> filesToTrim.fof
TQSfastq.pl -f filesToTrim.fof -q ${X_ARG} -n ${N_ARG} -e ${D_ARG}
cat ${READ1FQ}c${N_ARG}q${X_ARG}e${D_ARG}.fa \
    | perl -ne 'if(/^(\>\@\S+)/){print "${READ1FQ}b\n";}else{print;}' > read1.trimmed.fa
cat ${READ2FQ}c${N_ARG}q${X_ARG}e${D_ARG}.fa \
    | perl -ne 'if(/^(\>\@\S+)/){print "${READ1FQ}a\n";}else{print;}' > read2.trimmed.fa
DATE=`date`
echo -----------------------------------------------------------------------------------
echo ${DATE} : Formatting fasta input for SSAKE...
echo -----------------------------------------------------------------------------------
makePairedOutput2UNEQUALfiles.pl read1.trimmed.fa read2.trimmed.fa ${LFRAGLEN}
DATE=`date`
echo -----------------------------------------------------------------------------------
echo ${DATE} : Initiating SSAKE...
echo -----------------------------------------------------------------------------------
# TODO: Restore before committing
# time -v -o ${BASENAME}.time
SSAKE -f paired.fa -p 1 -g unpaired.fa -m ${M_ARG} -w ${W_ARG} -b ${BASENAME} \
      -o ${O_ARG} -r ${R_ARG} -t ${T_ARG} -c ${C_ARG} -y ${Y_ARG} -h ${K_ARG} \
      -z ${Z_ARG} -q ${Q_ARG} -v ${V_ARG}
DATE=`date`
echo -----------------------------------------------------------------------------------
echo ${DATE} : Computing stats 
echo -----------------------------------------------------------------------------------
getStats.pl ${BASENAME}_contigs.fa > ${BASENAME}_contigs_stats.txt
DATE=`date`
echo -----------------------------------------------------------------------------------
echo ${DATE} : Computing stats from ${BASENAME}_scaffolds.fa
echo -----------------------------------------------------------------------------------
getStats.pl ${BASENAME}_scaffolds.fa > ${BASENAME}_scaffolds.stats.txt
DATE=`date`
echo -----------------------------------------------------------------------------------
echo ${DATE} : assembly pipeline complete. Results are under ${BASENAME}.
